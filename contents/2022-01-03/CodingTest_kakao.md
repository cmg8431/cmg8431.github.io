---
date: '2022-01-03'
categories: ['CodingTest']
title: '크레인 인형뽑기'
summary: '오늘은 코딩 테스트 중 에서도 유명한 문제, 카카오 크레인 인형뽑기를 풀어 보았어요 !'
thumbnail: './Img/MainImg.png'
---

# 코딩테스트 준비

오늘은 얼마 남지 않은 취업준비를 위해 요즘 준비하고 있는 코딩 테스트에 대해서 끄적여보겠습니다. 물론 코딩테스트에 자신있는 편은 아니라.. 귀엽게 봐주시면 감사하겠습니다.

## 문제

그냥 간단하게 죠르디라는 친구가 크레인 인형뽑기 게임을 만드는 이야기 입니다. 처음에 문제를 보면 이게 무슨 소릴까.. 라는 생각이 들었지만 풀다보니까 그렇게 어려운 이야기는 아니더라구요.<br/><br/>

간단하게 문제에 대해서 알려드리고 시작하겠습니다.

```json
(전체적인 board의 구성)
[
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 3],
  [0, 2, 5, 0, 1],
  [4, 2, 4, 4, 2],
  [3, 5, 1, 3, 1]
]
```

간단하게 다음과 같은 board가 있다고 치겠습니다.

```json
(board의 한 칸)
  [0]
  [0]
  [0]
  [4]
  [3]
```

그리고 위의 board의 한 칸은 다음과 같이 세로 한칸이 1이 됩니다.

```json
(크레인의 이동 경로)
[1, 5, 3, 5, 1, 2, 1, 4]
```

위의 수는 크레인이 이동했던 움직임 입니다. 첫번째 칸... 다섯번째 칸... 이런 식으로 움직였다고 이해하시면 될거 같습니다. 그럼 저 예시를 보았을때 크레인의 첫번째 움직임은 1. 즉 첫번째 칸입니다. 어 그럼 0의 수가 뽑히는거 아닌가? 라고 생각하실 수 있지만 카카오 측에서 그렇게 문제를 쉽게 내지 않죠.<br/><br/>

0은 빈칸입니다. 즉 무시한단 소리죠. 그럼 크레인의 이동 경로 1은 맨 위의 칸의 0이 아닌 0을 무시하고 들어가 4가 뽑히게 됩니다. 그럼 1, 5, 3, 1, 2, 1, 4를 따라서 뽑히는 값은 순서대로 4 3 1 1 3 2 4의 값이 뽑혔다고 생각하시면 됩니다.<br/><br/>

그리고 이렇게 뽑힌 값 중 중간에 보시면 1, 1과 같이 같은 값이 연속적으로 뽑힌 부분을 확인하실 수 있습니다. 이런 값들은 바구니에 담는 과정에서 터트려진다고 하네요. 따라서 중간에 1, 1이 터지고 터지면서 중간에 있던 3과 3이 붙어 터지게 됩니다. 하여 총 4개의 인형이 터지게 되고 이 터진 값을 반환하는게 문제입니다.

## 해결

```javascript
function solution(board, moves) {
  let answer = 0;
  const basket = [];

  const horizontalBoard = board.map((v, i, arr) => {
    return arr.map(value => value[i]).filter(organizeItem => organizeItem != 0);
  });

  for (let i = 0; i < moves.length; i++) {
    const move = moves[i] - 1;
    const doll = horizontalBoard[move].shift();
    if (doll) {
      if (basket.length !== 0 && basket[basket.length - 1] === doll) {
        answer += 2;
        basket.pop();
      } else {
        basket.push(doll);
      }
    }
  }

  return answer;
}
```

일단 먼저 저는 board값을 세로에서 가로로 정렬 시켰습니다. 이후 정렬 시킨 값 중 0을 filter()를 통하여 제거 해주었습니다. 이 과정을 통해 값이 아래와 같이 정리된 것을 볼 수 있습니다.

```
[ [ 4, 3 ], [ 2, 2, 5 ], [ 1, 5, 4, 1 ], [ 4, 3 ], [ 3, 1, 2, 1 ] ]
```

그리고, moves의 길이만큼 반복문을 실행해주고, 이때 moves의 값은 1부터 시작이지만 index는 0부터 시작하기 때문에 -1을 해주었습니다. <br/><br/>

이후 doll에 horizontalBoard에서 shift()를 이용해 가장 위에 있는 인형을 가져온 후 doll에 인형이 있으면 if문을 실행하고, 실행이 되었다면 바스켓에 마지막으로 담긴 인형과 현재 꺼낸 인형이 일치할 때 바스켓에서 마지막 인형을 꺼내고 answer 값은 2를 올려주고, 반대로 그렇지 않은 경우 bascket에 넣어줌으로써 문제를 해결했습니다.
